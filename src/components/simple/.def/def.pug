append mixins
  mixin def(options = {}, items = [])
    -
      const items = (options.items || []).concat(items);
      delete options.items;

      options.class = `def `.concat(options.class || '');
      const mod = ((mod = '')=> new Set( mod.trim().split(/[,\s]\s*/) ))(options.mod)
      delete options.mod;
      // if (mod.includes('dropable'))
      const text = options.text ? `${options.text}` : '';
      delete options.text;
      const title = options.title ? `${options.title}` : '';
      delete options.title;

      options.class += mod.length ? ` def-${mod.join(` def-`)} ` : '';

      // в pug block передаётся строка с кодом функции в которой есть строковая переменная с распарсенным html переданых в block тегов
      // длинной block в данном случае считаю количество родительских html тегов переданных в block
      // т.к. мы получаем все теги как есть, то подсчёт тегов верхнего уровня это классический алгоритм на верификацию скобок
      // в нашем случае открывающая и закрывающая скобки, это < и </ соответсвенно
      // алгоритм избыточен, можно ограничиться числом и не хранить координаты скобок в массиве.
      // но мне в голову первой пришла такая мысль и мне было лень думать другую,
      // а оптимизация кода по скорости в препроцессоре безсмысленна. и мне лен
      function blockLength(block){
        // utf код < именно в таком виде они приходят в block
        const open = '\\u003C';
        // utf код </
        const close = '\\u003C'+'\\u002F';
        // массив координат открывающих скобок
        let begins = [];
        // собственно длинна block в смысле определённом выше
        let count = 0;

        // в i сохраняется первое вхождение open т.к. то что до него нас не волнует
        // indexOf возвращает -1 если не находит требуемое. потому цикл работает пока indexOf находит то что нужно
        // а нужно нам перебрать каждую открывающую скобку и строго по одному разу, потому i+1
        for(let i = block.indexOf(open,0); i>=0; i = block.indexOf(open,i+1)){
          // собственно если эта открывающая скбка не оказалась закрывающей, запоминаепм её координаты
          // а если оказалась, то удаляем последнюю запомненную открывающую скобку
          if (block.indexOf(close,i) != i)
            begins.push(i)
          else
            begins.pop();
          // теперь, если никаких скобок не хранится в массиве, то мы прошли ещё один тэг верхнего уровня. что собственно и запишем.
          if (begins.length <= 0)
            count++;
        }
        // а вот тут прикольней. не помню при каких условиях, но pug может раскидать переданный в block код на несколько функций. наверное если миксины скидывать ему.
        // и если не получилось посчитать количество тегов первым алгоритмом, хотя вроде это всегда должно срабатывать,
        // то я просто смотрю сколько функций переданно в block
        if (count <= 0)
          count = block.split(');').length - 1;
        return count;
      }

    div()&attributes(options)&attributes(attributes)
